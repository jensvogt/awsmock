name: Release + Build + Installer (Windows / macOS / Linux)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

env:
  APP_NAME: "awsmock"
  INSTALLER_ID: "de.jensvogt.awsmock"

permissions:
  contents: write
  pull-requests: write
  id-token: write
  pages: write

jobs:
  release-please:
    name: Create Release PR / Tag
    runs-on: ubuntu-latest

    outputs:
      release_created: ${{ steps.release.outputs.release_created }}
      tag_name: ${{ steps.strip_tag.outputs.clean_tag }}

    steps:
      - name: Release Please
        id: release
        uses: googleapis/release-please-action@v4
        with:
          release-type: simple
          token: ${{ secrets.GH_AUTH_TOKEN }}

      - name: Strip leading 'v' from tag
        id: strip_tag
        run: |
          TAG="${{ steps.release.outputs.tag_name }}"
          CLEAN="${TAG#v}"   # remove leading 'v'
          echo "clean_tag=$CLEAN" >> $GITHUB_OUTPUT

  build-windows:
    name: Build & Package (Windows)
    runs-on: windows-latest
    needs: release-please
    if: ${{ needs.release-please.outputs.release_created == 'true' }}
    env:
      BUILD_DIR: "${{ github.workspace }}/build-windows"
      PACKAGE_DIR: "${{ github.workspace }}/package-windows"
      SEMVER: ${{ needs.release-please.outputs.tag_name }}
      VCPKG_DEFAULT_TRIPLET: x64-windows-static
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Setup MSVC environment
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: x64

      - name: Ensure vcpkg toolchain exists (Windows)
        id: ensure-vcpkg-windows
        shell: pwsh
        run: |
          $v = Join-Path $Env:GITHUB_WORKSPACE 'vcpkg'
          if (-not (Test-Path $v)) {
            Write-Host "Cloning vcpkg into $v"
            git clone https://github.com/microsoft/vcpkg.git $v
            Write-Host "Bootstrapping vcpkg"
            & "${v}\bootstrap-vcpkg.bat"
          } else {
            Write-Host "vcpkg already present at $v"
          }

      - name: Setup vcpkg (using lukka/run-vcpkg)
        uses: lukka/run-vcpkg@v11
        with:
          vcpkgJsonGlob: 'vcpkg.json'
          vcpkgDirectory: '${{ github.workspace }}/vcpkg'
          runVcpkgInstall: true
          doNotCache: false

      - name: Build (Backend)
        shell: cmd
        run: |
          mkdir ${{ env.BUILD_DIR }}
          cmake -B ${{ env.BUILD_DIR }} -S . -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=${{ env.VCPKG_ROOT }}/scripts/buildsystems/vcpkg.cmake
          cmake --build ${{ env.BUILD_DIR }} --config Release --parallel

      - name: Build (Frontend)
        shell: cmd
        run: |
          mkdir -p ${{ github.workspace }}\frontend
          cd ${{ github.workspace }}\frontend
          git clone https://github.com/jensvogt/awsmock-ui
          cd awsmock-ui
          npm install
          npm run build

      - name: Create package structure
        shell: cmd
        run: |
          mkdir ${{ env.PACKAGE_DIR }}\bin
          mkdir ${{ env.PACKAGE_DIR }}\etc
          mkdir ${{ env.PACKAGE_DIR }}\log
          mkdir ${{ env.PACKAGE_DIR }}\data
          mkdir ${{ env.PACKAGE_DIR }}\init
          mkdir ${{ env.PACKAGE_DIR }}\data\s3
          mkdir ${{ env.PACKAGE_DIR }}\data\sqs
          mkdir ${{ env.PACKAGE_DIR }}\data\sns
          mkdir ${{ env.PACKAGE_DIR }}\data\lambda
          mkdir ${{ env.PACKAGE_DIR }}\data\application
          mkdir ${{ env.PACKAGE_DIR }}\data\transfer
          mkdir ${{ env.PACKAGE_DIR }}\data\backup
          mkdir ${{ env.PACKAGE_DIR }}\data\tmp
          copy ${{ env.BUILD_DIR }}\Release\awsmockmgr ${{ env.PACKAGE_DIR }}\bin
          copy ${{ env.BUILD_DIR }}\Release\awsmockctl ${{ env.PACKAGE_DIR }}\bin
          copy ${{ env.BUILD_DIR }}\Release\awslocal ${{ env.PACKAGE_DIR }}\bin
          copy dist\etc\awsmock_win32.json ${{ env.PACKAGE_DIR }}\etc\awsmock.json
          copy dist\etc\magic.mgc ${{ env.PACKAGE_DIR }}\etc\magic.mgc
          copy dist\etc\ssh_host_key ${{ env.PACKAGE_DIR }}\etc\ssh_host_key
          robocopy /E /NFL /NDL /NS /NC frontend\awsmock-ui\dist\awsmock-ui\browser ${{ env.PACKAGE_DIR }}\frontend

      - name: Create ZIP archive (PowerShell)
        shell: pwsh
        run: |
          $source = "${{ env.PACKAGE_DIR }}"
          $zip = "${{ env.APP_NAME }}-${{ env.SEMVER }}-amd64.zip"
          
          if (Test-Path $zip) {
            Remove-Item $zip -Force
          }
          
          Add-Type -AssemblyName 'System.IO.Compression.FileSystem'
          [System.IO.Compression.ZipFile]::CreateFromDirectory($source, $zip)

      - name: Upload Windows installer
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-${{ env.SEMVER }}-amd64.zip
          path: ${{ env.APP_NAME }}-${{ env.SEMVER }}-amd64.zip
          overwrite: true

  build-macos:
    name: Build & Package (macOS)
    runs-on: macos-latest
    needs: release-please
    #if: ${{ needs.release-please.outputs.release_created == 'true' }}
    env:
      BUILD_DIR: "${{ github.workspace }}/build-macos"
      PACKAGE_DIR: "${{ github.workspace }}/package-macos"
      SEMVER: ${{ needs.release-please.outputs.tag_name }}
      SERVICE_NAME: de.jensvogt.awsmock
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Install system dependencies
        shell: bash
        run: |
          brew install doxygen pandoc file autoconf autoconf-archive automake libtool
      #
      #      - name: Ensure vcpkg.json exists (fallback)
      #        shell: bash
      #        run: |
      #          vf="${{ github.workspace }}/vcpkg.json"
      #          if [ ! -f "$vf" ]; then
      #            echo "vcpkg.json not found; creating minimal fallback at $vf"
      #          else
      #            echo "vcpkg.json found at $vf"
      #          fi
      #
      #      - name: Ensure vcpkg toolchain exists (macOS)
      #        shell: bash
      #        run: |
      #          v="${{ github.workspace }}/vcpkg"
      #          if [ ! -d "$v" ]; then
      #            echo "Cloning vcpkg into $v"
      #            git clone https://github.com/microsoft/vcpkg.git "$v"
      #            echo "Bootstrapping vcpkg"
      #            "${v}/bootstrap-vcpkg.sh"
      #          else
      #            echo "vcpkg already present at $v"
      #          fi
      #
      #      - name: Setup vcpkg (using lukka/run-vcpkg)
      #        id: vcpkg-installation
      #        uses: lukka/run-vcpkg@v11
      #        with:
      #          vcpkgJsonGlob: '${{ github.workspace }}/vcpkg.json'
      #          vcpkgDirectory: '${{ github.workspace }}/vcpkg'
      #          runVcpkgInstall: true
      #          doNotCache: false
      #          cmake -B ${{ env.BUILD_DIR }} -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=${{ env.VCPKG_ROOT }}/scripts/buildsystems/vcpkg.cmake
      #          cmake --build ${{ env.BUILD_DIR }} --config Release

      - name: Build (Backend)
        run: |
          mkdir ${{ env.BUILD_DIR }}
          touch ${{ env.BUILD_DIR }}/awsmockmgr
          touch ${{ env.BUILD_DIR }}/awsmockctl
          touch ${{ env.BUILD_DIR }}/awslocal


      - name: Build (Frontend)
        shell: bash
        run: |
          mkdir -p ${{ github.workspace }}/frontend
          cd ${{ github.workspace }}/frontend
          git clone https://github.com/jensvogt/awsmock-ui
          cd awsmock-ui
          npm install
          npm run build

      - name: Prepare package structure
        run: |
          mkdir -p ${{ env.PACKAGE_DIR }}/awsmock/bin
          mkdir -p ${{ env.PACKAGE_DIR }}/awsmock/etc
          mkdir -p ${{ env.PACKAGE_DIR }}/awsmock/log
          mkdir -p ${{ env.PACKAGE_DIR }}/awsmock/frontend
          mkdir -p ${{ env.PACKAGE_DIR }}/awsmock/data/s3
          mkdir -p ${{ env.PACKAGE_DIR }}/awsmock/data/sqs
          mkdir -p ${{ env.PACKAGE_DIR }}/awsmock/data/sns
          mkdir -p ${{ env.PACKAGE_DIR }}/awsmock/data/lambda
          mkdir -p ${{ env.PACKAGE_DIR }}/awsmock/data/application
          mkdir -p ${{ env.PACKAGE_DIR }}/awsmock/data/transfer
          mkdir -p ${{ env.PACKAGE_DIR }}/awsmock/data/backup
          mkdir -p ${{ env.PACKAGE_DIR }}/awsmock/data/tmp
          mkdir -p ${{ env.PACKAGE_DIR }}/awsmock/share/man/man1
          
          # Copy your app
          #          cp docs/man/*.1 ${{ env.PACKAGE_DIR }}/awsmock/share/man/man1
          cp ${{ env.BUILD_DIR }}/awsmockmgr ${{ env.PACKAGE_DIR }}/awsmock/bin/
          cp ${{ env.BUILD_DIR }}/awsmockctl ${{ env.PACKAGE_DIR }}/awsmock/bin/
          cp ${{ env.BUILD_DIR }}/awslocal ${{ env.PACKAGE_DIR }}/awsmock/bin/
          cp dist/etc/awsmock_macos.json ${{ env.PACKAGE_DIR }}/awsmock/etc/awsmock.json
          cp dist/etc/magic.mgc ${{ env.PACKAGE_DIR }}/awsmock/etc/magic.mgc
          cp dist/etc/ssh_host_key ${{ env.PACKAGE_DIR }}/awsmock/etc/ssh_host_key
          cp -R ${{ github.workspace }}/frontend/awsmock-ui/dist/awsmock-ui/browser/* ${{ env.PACKAGE_DIR }}/awsmock/frontend

      - name: Create Launch Agent Plist
        run: |
          cat << EOF > ${{ env.PACKAGE_DIR }}/awsmock/etc/awsmock.plist
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
            <dict>
               <key>Label</key>
               <string>${{ env.SERVICE_NAME }}</string>
               <key>ProgramArguments</key>
               <array>
                   <string>${{ env.EXECUTABLE_NAME }}</string>
                   <string>--config</string>
                   <string>$HOME/awsmock/etc/awsmock.json</string>
               </array>
               <key>RunAtLoad</key>
               <true/>
               <key>KeepAlive</key>
               <false/>
               <key>StandardOutPath</key>
               <string>/tmp/${{ env.SERVICE_NAME }}.log</string>
            </dict>
          </plist>
          EOF

      - name: Package Service Files
        run: |
          echo "SEMVER: ${{ env.SEMVER }}"
          tar -czf ${{ env.APP_NAME }}-${{ env.SEMVER }}-macos.tgz -C ${{ env.PACKAGE_DIR }} .

      - name: Upload macOS ZIP
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-${{ env.SEMVER }}-macos.tgz
          path: ${{ env.APP_NAME }}-${{ env.SEMVER }}-macos.tgz

  build-linux-deb:
    name: Build & Package (Linux DEB)
    runs-on: ubuntu-latest
    needs: release-please
    if: ${{ needs.release-please.outputs.release_created == 'true' }}
    env:
      PACKAGE_DIR: "${{ github.workspace }}/package-deb"
      BUILD_DIR: "${{ github.workspace }}/build-deb"
      SEMVER: "${{ needs.release-please.outputs.tag_name }}"
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Install system dependencies
        run: |
          sudo apt update
          sudo apt install -y ninja-build doxygen pandoc linux-libc-dev autoconf autoconf-archive automake libtool
          sudo gem install --no-document fpm

      - name: Ensure vcpkg.json exists (fallback)
        shell: bash
        run: |
          vf="${{ github.workspace }}/vcpkg.json"
          if [ ! -f "$vf" ]; then
            echo "vcpkg.json not found; creating minimal fallback at $vf"
          else
            echo "vcpkg.json found at $vf"
          fi

      - name: Ensure vcpkg toolchain exists (Linux)
        shell: bash
        run: |
          v="${{ github.workspace }}/vcpkg"
          if [ ! -d "$v" ]; then
            echo "Cloning vcpkg into $v"
            git clone https://github.com/microsoft/vcpkg.git "$v"
            echo "Bootstrapping vcpkg"
            "${v}/bootstrap-vcpkg.sh"
          else
            echo "vcpkg already present at $v"
          fi

      - name: Setup vcpkg (using lukka/run-vcpkg)
        id: vcpkg-installation
        uses: lukka/run-vcpkg@v11
        with:
          vcpkgJsonGlob: '${{ github.workspace }}/vcpkg.json'
          vcpkgDirectory: '${{ github.workspace }}/vcpkg'
          runVcpkgInstall: true
          doNotCache: false

      - name: Build (Backend)
        run: |
          mkdir ${{ env.BUILD_DIR }}
          cmake -B ${{ env.BUILD_DIR }} -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=${{ env.VCPKG_ROOT }}/scripts/buildsystems/vcpkg.cmake
          cmake --build ${{ env.BUILD_DIR }} --config Release --parallel

      - name: Build (Frontend)
        shell: bash
        run: |
          mkdir -p ${{ github.workspace }}/frontend
          cd ${{ github.workspace }}/frontend
          git clone https://github.com/jensvogt/awsmock-ui
          cd awsmock-ui
          npm install
          npm run build

      - name: Prepare package structure
        run: |
          mkdir -p ${{ env.PACKAGE_DIR }}/DEBIAN
          mkdir -p ${{ env.PACKAGE_DIR }}/usr/local/awsmock/bin
          mkdir -p ${{ env.PACKAGE_DIR }}/usr/local/awsmock/etc
          mkdir -p ${{ env.PACKAGE_DIR }}/usr/local/awsmock/log
          mkdir -p ${{ env.PACKAGE_DIR }}/usr/local/awsmock/frontend
          mkdir -p ${{ env.PACKAGE_DIR }}/usr/local/awsmock/data/s3
          mkdir -p ${{ env.PACKAGE_DIR }}/usr/local/awsmock/data/sqs
          mkdir -p ${{ env.PACKAGE_DIR }}/usr/local/awsmock/data/sns
          mkdir -p ${{ env.PACKAGE_DIR }}/usr/local/awsmock/data/lambda
          mkdir -p ${{ env.PACKAGE_DIR }}/usr/local/awsmock/data/application
          mkdir -p ${{ env.PACKAGE_DIR }}/usr/local/share/man/man1
          mkdir -p ${{ env.PACKAGE_DIR }}/etc/systemd/system
          mkdir -p ${{ env.PACKAGE_DIR }}/etc/ld.so.conf.d
          mkdir -p ${{ env.PACKAGE_DIR }}/DEBIAN
          
          # Copy your app
          cp ${{ env.BUILD_DIR }}/awsmockmgr ${{ env.PACKAGE_DIR }}/usr/local/awsmock/bin/
          cp ${{ env.BUILD_DIR }}/awsmockctl ${{ env.PACKAGE_DIR }}/usr/local/awsmock/bin/
          cp ${{ env.BUILD_DIR }}/awslocal ${{ env.PACKAGE_DIR }}/usr/local/awsmock/bin/
          cp dist/etc/awsmock_linux.json ${{ env.PACKAGE_DIR }}/usr/local/awsmock/etc/awsmock.json
          cp dist/etc/magic.mgc ${{ env.PACKAGE_DIR }}/usr/local/awsmock/etc/magic.mgc
          cp dist/etc/ssh_host_key ${{ env.PACKAGE_DIR }}/usr/local/awsmock/etc/ssh_host_key
          cp dist/etc/systemd/system/awsmock.service ${{ env.PACKAGE_DIR }}/etc/systemd/system
          cp docs/man/*.1 ${{ env.PACKAGE_DIR }}/usr/local/share/man/man1
          cp -R frontend/awsmock-ui/dist/awsmock-ui/browser/* ${{ env.PACKAGE_DIR }}/usr/local/awsmock/frontend
          
          # Create control file
          cat << EOF > ${{ env.PACKAGE_DIR }}/DEBIAN/control
          Package: awsmock
          Version: ${SEMVER}
          Section: utils
          Priority: optional
          Architecture: amd64
          Maintainer: Jens Vogt <jens.vogt@opitz-consulting.com>
          Description: AWSMock local AWS emulator service
          Depends: systemd
          EOF
          
          # Create postinst
          cat << EOF > ${{ env.PACKAGE_DIR }}/DEBIAN/postinst
          #!/bin/bash
          set -e
          systemctl daemon-reload
          systemctl enable awsmock.service
          systemctl restart awsmock.service || true
          ldconfig
          EOF
          
          # Create postrm
          cat << EOF > ${{ env.PACKAGE_DIR }}/DEBIAN/postrm
          #!/bin/bash
          set -e
          systemctl stop awsmock.service || true
          systemctl disable awsmock.service || true
          rm -rf /etc/systemd/system/awsmock.service
          rm -rf ${{ env.PACKAGE_DIR }}/etc/ld.so.conf.d/awsmock.conf
          ldconfig
          EOF
          
          # Create ldconfig config
          cat << EOF > ${{ env.PACKAGE_DIR }}/etc/ld.so.conf.d/awsmock.conf
          /usr/local/awsmock/lib
          EOF
          
          chmod 755 ${{ env.PACKAGE_DIR }}/DEBIAN/postinst $PACKAGE_DIR/DEBIAN/postrm

      - name: Build DEB with fpm
        run: |
          fpm -s dir -t deb --name "${{ env.APP_NAME }}" \
          --version "${{ env.SEMVER }}" \
          --architecture amd64 \
          --package "${{ env.APP_NAME }}-${{ env.SEMVER }}-amd64.deb" \
          ${{ env.PACKAGE_DIR }}/=/

      - name: Upload .deb
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-${{ env.SEMVER }}-amd64.deb
          path: ${{ env.APP_NAME }}-${{ env.SEMVER }}-amd64.deb
          overwrite: true

  build-linux-rpm:
    name: Build & Package (Linux RPM)
    runs-on: ubuntu-latest
    needs: release-please
    if: ${{ needs.release-please.outputs.release_created == 'true' }}
    env:
      PACKAGE_DIR: "${{ github.workspace }}/package-rpm"
      BUILD_DIR: "${{ github.workspace }}/build-rpm"
      SEMVER: "${{ needs.release-please.outputs.tag_name }}"
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Install system dependencies
        run: |
          sudo apt update
          sudo apt install -y ninja-build doxygen pandoc linux-libc-dev autoconf autoconf-archive automake libtool
          sudo gem install --no-document fpm

      - name: Ensure vcpkg.json exists (fallback)
        shell: bash
        run: |
          vf="${{ github.workspace }}/vcpkg.json"
          if [ ! -f "$vf" ]; then
            echo "vcpkg.json not found; creating minimal fallback at $vf"
          else
            echo "vcpkg.json found at $vf"
          fi

      - name: Ensure vcpkg toolchain exists (Linux)
        shell: bash
        run: |
          v="${{ github.workspace }}/vcpkg"
          if [ ! -d "$v" ]; then
            echo "Cloning vcpkg into $v"
            git clone https://github.com/microsoft/vcpkg.git "$v"
            echo "Bootstrapping vcpkg"
            "${v}/bootstrap-vcpkg.sh"
          else
            echo "vcpkg already present at $v"
          fi

      - name: Setup vcpkg (using lukka/run-vcpkg)
        id: vcpkg-installation
        uses: lukka/run-vcpkg@v11
        with:
          vcpkgJsonGlob: '${{ github.workspace }}/vcpkg.json'
          vcpkgDirectory: '${{ github.workspace }}/vcpkg'
          runVcpkgInstall: true
          doNotCache: false

      - name: Build (Backend)
        run: |
          mkdir ${{ env.BUILD_DIR }}
          cmake -B ${{ env.BUILD_DIR }} -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_TOOLCHAIN_FILE=${{ env.VCPKG_ROOT }}/scripts/buildsystems/vcpkg.cmake
          cmake --build ${{ env.BUILD_DIR }} --config Release --parallel

      - name: Build (Frontend)
        shell: bash
        run: |
          mkdir -p ${{ github.workspace }}/frontend
          cd ${{ github.workspace }}/frontend
          git clone https://github.com/jensvogt/awsmock-ui
          cd awsmock-ui
          npm install
          npm run build

      - name: Prepare package structure
        run: |
          mkdir -p ${{ env.PACKAGE_DIR }}/DEBIAN
          mkdir -p ${{ env.PACKAGE_DIR }}/usr/local/awsmock/bin
          mkdir -p ${{ env.PACKAGE_DIR }}/usr/local/awsmock/etc
          mkdir -p ${{ env.PACKAGE_DIR }}/usr/local/awsmock/log
          mkdir -p ${{ env.PACKAGE_DIR }}/usr/local/awsmock/data/s3
          mkdir -p ${{ env.PACKAGE_DIR }}/usr/local/awsmock/data/sqs
          mkdir -p ${{ env.PACKAGE_DIR }}/usr/local/awsmock/data/sns
          mkdir -p ${{ env.PACKAGE_DIR }}/usr/local/awsmock/data/lambda
          mkdir -p ${{ env.PACKAGE_DIR }}/usr/local/awsmock/data/application
          mkdir -p ${{ env.PACKAGE_DIR }}/usr/local/awsmock/frontend
          mkdir -p ${{ env.PACKAGE_DIR }}/usr/local/share/man/man1
          mkdir -p ${{ env.PACKAGE_DIR }}/etc/systemd/system
          mkdir -p ${{ env.PACKAGE_DIR }}/etc/ld.so.conf.d
          mkdir -p ${{ env.PACKAGE_DIR }}/scripts
          
          # Copy app
          cp ${{ env.BUILD_DIR }}/awsmockmgr ${{ env.PACKAGE_DIR }}/usr/local/awsmock/bin/
          cp ${{ env.BUILD_DIR }}/awsmockctl ${{ env.PACKAGE_DIR }}/usr/local/awsmock/bin/
          cp ${{ env.BUILD_DIR }}/awslocal ${{ env.PACKAGE_DIR }}/usr/local/awsmock/bin/
          cp dist/etc/awsmock_linux.json ${{ env.PACKAGE_DIR }}/usr/local/awsmock/etc/awsmock.json
          cp dist/etc/magic.mgc ${{ env.PACKAGE_DIR }}/usr/local/awsmock/etc/magic.mgc
          cp dist/etc/ssh_host_key ${{ env.PACKAGE_DIR }}/usr/local/awsmock/etc/ssh_host_key
          cp dist/etc/systemd/system/awsmock.service ${{ env.PACKAGE_DIR }}/etc/systemd/system
          cp docs/man/*.1 ${{ env.PACKAGE_DIR }}/usr/local/share/man/man1
          cp -R frontend/awsmock-ui/dist/awsmock-ui/browser/* ${{ env.PACKAGE_DIR }}/usr/local/awsmock/frontend
          
          # Create postinstall
          cat << EOF > ${{ env.PACKAGE_DIR }}/scripts/postinstall.sh
          #!/bin/bash
          set -e
          systemctl daemon-reload
          systemctl enable awsmock.service
          systemctl restart awsmock.service || true
          ldconfig
          EOF
          
          # Create postremove
          cat << EOF > ${{ env.PACKAGE_DIR }}/scripts/postremove.sh
          #!/bin/bash
          systemctl stop awsmock.service || true
          systemctl disable awsmock.service || true
          rm -f /etc/systemd/system/awsmock.service
          systemctl daemon-reload
          rm -f /etc/ld.so.conf.d/awsmock.conf
          ldconfig
          EOF
          
          chmod +x ${{ env.PACKAGE_DIR }}/scripts/postinstall.sh $PACKAGE_DIR/scripts/postremove.sh
          
          # Create ldconfig config
          cat << EOF > ${{ env.PACKAGE_DIR }}/etc/ld.so.conf.d/awsmock.conf
          /usr/local/awsmock/lib
          EOF

      - name: Build RPM using FPM
        run: |
          fpm -s dir -t rpm \
          -n awsmock \
          -v ${SEMVER} \
          --description "AWSMock â€“ Local AWS API mocking environment" \
          --url "https://github.com/jensvogt/awsmock" \
          --vendor "AWSMock Project" \
          --license "Apache-2.0" \
          --prefix / \
          --after-install ${{ env.PACKAGE_DIR }}/scripts/postinstall.sh \
          --after-remove ${{ env.PACKAGE_DIR }}/scripts/postremove.sh \
          ${{ env.PACKAGE_DIR }}/=/

      - name: Upload .rpm
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-${{ env.SEMVER }}-1.x86_64.rpm
          path: ${{ env.APP_NAME }}-${{ env.SEMVER }}-1.x86_64.rpm
          overwrite: true

  build-docker:
    name: "Build & Package (Docker)"
    runs-on: ubuntu-latest
    needs: release-please
    if: ${{ needs.release-please.outputs.release_created == 'true' }}
    env:
      GH_TOKEN: ${{ github.token }}
      SEMVER: "${{ needs.release-please.outputs.tag_name }}"
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Build Docker
        run: |
          cd docker
          docker build --no-cache --build-arg GH_TOKEN=${GH_TOKEN} -t awsmock:$SEMVER .

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USER }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Tag images
        run: |
          docker tag awsmock:${{ env.SEMVER }} ${{ secrets.DOCKER_USER }}/awsmock:${{ env.SEMVER }}
          docker push ${{ secrets.DOCKER_USER }}/awsmock:${{ env.SEMVER }}
          docker tag awsmock:$SEMVER ${{ secrets.DOCKER_USER }}/awsmock:latest
          docker push ${{ secrets.DOCKER_USER }}/awsmock:latest

  publish:
    name: Publish Release & Attach Installers
    runs-on: ubuntu-latest
    needs: [ release-please, build-linux-deb, build-linux-rpm ]
    env:
      SEMVER: "${{ needs.release-please.outputs.tag_name }}"
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Download Windows installer
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-${{ env.SEMVER }}-amd64.zip
          path: artifacts/windows

      - name: Download macOS installer
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-${{ env.SEMVER }}-macos.tgz
          path: artifacts/macos

      - name: Download Linux Debian package
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-${{ env.SEMVER }}-amd64.deb
          path: artifacts/linux

      - name: Download Linux RPM package
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.APP_NAME }}-${{ env.SEMVER }}-1.x86_64.rpm
          path: artifacts/linux

      - name: Create GitHub Release (attach installers)
        uses: softprops/action-gh-release@v2
        with:
          files: |
            artifacts/windows/*.zip
            artifacts/macos/*.tgz
            artifacts/linux/*.deb
            artifacts/linux/*.rpm
          name: Release ${{ env.SEMVER }}
          tag_name: ${{ env.SEMVER }}
          body: "Automated release for ${{ env.SEMVER }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GH_AUTH_TOKEN }}

  deploy:
    needs:
      - publish
    runs-on: ubuntu-latest
    env:
      SEMVER: "${{ needs.release-please.outputs.tag_name }}"
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Create site folder
        run: |
          mkdir public
          cp ./artifacts/awsmock-${{ env.SEMVER }}-amd64.deb/awsmock-${{ env.SEMVER }}-amd64.deb public/ || true
          cp ./artifacts/awsmock-${{ env.SEMVER }}-1.x86_64.rpm/awsmock-${{ env.SEMVER }}-1.x86_64.rpm public/ || true
          cp .github/pages/index.html public/index.html

      - name: Generate files.json
        run: |
          cd public
          echo '{ "downloads": [' > files.json
          first=true
          for f in *.{zip,deb,rpm,tgz}; do
            [ -f "$f" ] || continue
            if [ "$first" = true ]; then
              first=false
            else
              echo "," >> files.json
            fi
            size=$(stat -c%s "$f")
            sha=$(sha256sum "$f" | cut -d" " -f1)
            echo "  {\"file\": \"$f\", \"size\": $size, \"sha256\": \"$sha\"}" >> files.json
          done
          echo "]}" >> files.json

      - name: Upload GitHub Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: public

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4